#ifndef shell__builtins\n#define shell__builtins\n\n#define dothis(what, times) {\\\n\tfor(int i = 0;i<times;i++) { what }; \\\n}\n\n#ifndef SHELL\nstruct shell {\n\tchar * name;\n} shell;\nshell.name = \"Shell\";\n#endif\n\n\n#ifndef DEBUG\n#define DEBUG\n#endif\n\n#ifndef DEBUG2\n#define DEBUG2\n#endif\n\n#ifndef DEBUG_SLEEP\n#define DEBUG_SLEEP /* printf(\"sleeping for 2 seconds\\n\") ; sleep(2) ; */\n#endif\n\n#include \"colors.h\"\n\n#ifndef PASSED\n#define PASSED DEBUG2 DEBUG_SLEEP fprintf(stderr, \"passed %s() at line %d from %s\\n\", __func__, __LINE__, __FILE__);\n#endif\n\n#ifndef PASSED_COLORS\n#define PASSED_COLORS\n#define PASSED_B DEBUG2 DEBUG_SLEEP fprintf_b(stderr, \"passed %s() at line %d from %s\\n\", __func__, __LINE__, __FILE__);\n#define PASSED_R DEBUG2 DEBUG_SLEEP fprintf_r(stderr, \"passed %s() at line %d from %s\\n\", __func__, __LINE__, __FILE__);\n#define PASSED_M DEBUGw DEBUG_SLEEP fprintf_m(stderr, \"passed %s() at line %d from %s\\n\", __func__, __LINE__, __FILE__);\n#endif\n\n#ifndef CURRENT_FUNCTION\n#define CURRENT_FUNCTION DEBUG2 printf(\"->called %s() at line %d from %s\\n\", __func__, __LINE__, __FILE__);\n#endif\n\n#define pc(x) printf(\"%s = %c\\n\", #x, x);\n#define puc(x) printf(\"%s = %c\\n\", #x, x);\n#define ps(x) printf(\"%s = %s\\n\", #x, x);\n#define pus(x) printf(\"%s = %s\\n\", #x, x);\n#define pi(x) printf(\"%s = %d\\n\", #x, x);\n#define pui(x) printf(\"%s = %u\\n\", #x, x);\n#define pd(x) printf(\"%s = %f\\n\", #x, x);\n#define pud(x) printf(\"%s = %f\\n\", #x, x);\n#define pl(x) printf(\"%s = %l\\n\", #x, x);\n#define pul(x) printf(\"%s = %lu\\n\", #x, x);\n#define pll(x) printf(\"%s = %ll\\n\", #x, x);\n#define pull(x) printf(\"%s = %llu\\n\", #x, x);\n#define psz(x) printf(\"%s = %zu\\n\", #x, x);\n#define pp(x) printf(\"%s = %p\\n\", #x, x);\n#define px(x) printf(\"%s = %02x\\n\", #x, x);\n#define p(x) printf(#x);\n\n#include \"libstring.h\"\n#include \"env.h\"\n#include <SDL.h>\n#include <inttypes.h>\n#include \"argv.h\"\n#include \"grep.h\" // not needed but included if it ever is\n#include \"regex.h\"\n#include <stdio.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef __CCR__\n#include <ccr.h>\n#endif\n#include <stdio.h>\n#include <dirent.h>\n#include <sys/types.h>\n\n\nchar * quote (char * str) { \n\tchar * p = malloc(strlen(str)+3); \n\tsprintf(p, \"\\\"%s\\\"\", str); \n\treturn p;\n}\n\n#define mq(a, b) char * a = quote(b)\n\n#ifndef SPLIT\n#define SPLIT\nint split (const char *strconst, char c, char ***arr)\n{\n    int count = 1;\n    int token_len = 1;\n    int i = 0;\n    char *p;\n    char *t;\n    char * str = strdup(strconst);\n\n    p = str;\n    while (*p != \'\\0\')\n    {\n        if (*p == c)\n            count++;\n        p++;\n    }\n    *arr = NULL;\n\n    *arr = (char**) malloc(sizeof(char*) * count);\n    if (*arr == NULL) {\n    \tfree(str);\n        return -1;\n    }\n\n    p = str;\n    while (*p != \'\\0\')\n    {\n        if (*p == c)\n        {\n            (*arr)[i] = (char*) malloc( sizeof(char) * token_len );\n            if ((*arr)[i] == NULL) {\n\t\t    \tfree(str);\n\t\t        return -1;\n\t\t    }\n\n            token_len = 0;\n            i++;\n        }\n        p++;\n        token_len++;\n    }\n    (*arr)[i] = (char*) malloc( sizeof(char) * token_len );\n    if ((*arr)[i] == NULL) {\n\t\tfree(str);\n\t\treturn -1;\n\t}\n\n    i = 0;\n    p = str;\n    t = ((*arr)[i]);\n    while (*p != \'\\0\')\n    {\n        if (*p != c && *p != \'\\0\')\n        {\n            *t = *p;\n            t++;\n        }\n        else\n        {\n            *t = \'\\0\';\n            i++;\n            t = ((*arr)[i]);\n        }\n        p++;\n    }\n    *t = \'\\0\';\n    \n    free(str);\n\n    return count;\n}\n\nvoid freesplit(int c, char *** a) {\n\tfor (int i = 0; i < c; i++) free((*a)[i]);\n\tfree(*a);\n}\n\n#endif\n\nint builtin__CPU_Info(void) {\n\tUint64 PerformanceCounter = SDL_GetPerformanceCounter();\n\tUint64 PerformanceFrequency = SDL_GetPerformanceFrequency();\n\tint CPUCount = SDL_GetCPUCount();\n\tint CPUCacheLineSize = SDL_GetCPUCacheLineSize();\n\tint RAM = SDL_GetSystemRAM();\n\tint seconds, pct;\n\tSDL_GetPowerInfo(&seconds, &pct);\n\tprintf(\"System Information:\\n    CPU Count: %d\\n    CPU Cache Line Size: %d\\n    Performance Counter: %zd\\n    Performance Frequency: %zd\\n    RAM: %d\\n\",\n\tCPUCount,\n\tCPUCacheLineSize,\n\tPerformanceCounter,\n\tPerformanceFrequency,\n\tRAM\n\t);\n\treturn 0;\n}\n\n//Original source code found at : http://c2.com/cgi/wiki?HexDumpInManyProgrammingLanguages\n#define cat 0\n#define hex 1\n#define both 2\n#define json 3\n\nint mode;\n\nchar * builtin__whereis(char ** f, const char * extention, int skip_arg0);\n\nvoid __hexdump(unsigned char *buffer, unsigned long index, unsigned long width)\n{\n\tunsigned long i;\n\tif (mode == both || mode == hex) {\n\tfor (i = 0; i < index; i++)\n\t\tprintf(\"%02x \", buffer[i]);\n\t}\n\tif (mode == both) {\n\tfor (unsigned long spacer = index; spacer < width; spacer++)\n\t\tprintf(\"\\t\");\n\tprintf(\": \");\n\t}\n\tif (mode == cat || mode == both || mode == json) {\n\tfor (i = 0; i < index; i++)\n\t{\n\t\tif (buffer[i] < 32 || buffer[i] >= 127)\n\t\t\tprintf(\".\");\n\t\telse\n\t\t\tprintf(\"%c\", buffer[i]);\n\t}\n\t}\n\tprintf(\"\\n\");\n}\n\nint __hexdump_file(FILE *infile, unsigned long start, unsigned long stop, unsigned long width)\n{\n\tchar ch;\n\tunsigned long f_index = 0;\n\tunsigned long bb_index = 0;\n\tunsigned char *byte_buffer = malloc(width);\n\tif (byte_buffer == NULL)\n\t{\n\t\tprintf(\"Could not allocate memory for byte_buffer\\n\");\n\t\treturn -1;\n\t}\n\twhile (!feof(infile))\n\t{\n\t\tch = getc(infile);\n\t\tif ((f_index >= start) && (f_index <= stop))\n\t\t{\n\t\t\tbyte_buffer[bb_index] = ch;\n\t\t\tbb_index++;\n\t\t}\n\t\tif (bb_index >= width)\n\t\t{\n\t\t\t__hexdump(byte_buffer, bb_index, width);\n\t\t\tbb_index = 0;\n\t\t}\n\t\tf_index++;\n\t}\n\tif (bb_index)\n\t\t__hexdump(byte_buffer, bb_index, width);\n\tfclose(infile);\n\tfree(byte_buffer);\n\treturn 0;\n}\n\nint __hexdump_string(char *infile, unsigned long start, unsigned long stop, unsigned long width)\n{\n\tchar ch;\n\tunsigned long f_index = 0;\n\tunsigned long bb_index = 0;\n\tunsigned char *byte_buffer = malloc(width);\n\tif (byte_buffer == NULL)\n\t{\n\t\tprintf(\"Could not allocate memory for byte_buffer\\n\");\n\t\treturn -1;\n\t}\n\twhile (*infile)\n\t{\n\t\tch = *infile;\n\t\tif ((f_index >= start) && (f_index <= stop))\n\t\t{\n\t\t\tbyte_buffer[bb_index] = ch;\n\t\t\tbb_index++;\n\t\t}\n\t\tif (bb_index >= width)\n\t\t{\n\t\t\t__hexdump(byte_buffer, bb_index, width);\n\t\t\tbb_index = 0;\n\t\t}\n\t\tf_index++;\n\t\tinfile++;\n\t}\n\tif (bb_index)\n\t\t__hexdump(byte_buffer, bb_index, width);\n\tfree(byte_buffer);\n\treturn 0;\n}\n\nint __cathex(const char **args)\n{\n\tmq(qt, args[1]);\n\tps(qt)\n\tfree(qt);\n\tint result;\n\tconst char * file;\n\tif (args[1] == NULL || strcmp(args[1], \"\") ==  0) {\n\t\tchar ** a;\n\t\tint c = split(\"Built-Ins/Built-Ins\", \' \', &a);\n\t\tfile = builtin__whereis(a, \".h\", false);\n\t\tfreesplit(c, &a);\n\t}\n\telse file = args[1];\n\tif (mode == cat || mode == hex || mode == json) {\n\t\tchar * buf;\n\t\tsize_t size;\n\t\tread__(file, &buf, &size);\n\t\tresult = __hexdump((unsigned char *)buf, (unsigned long)size, 0);\n\t}\n\telse if (mode == both) {\n\tint start = 0, width = 16+8;\n\tsize_t length;\n\tchar * disregard;\n\tread__(file, &disregard, &length);\n\tFILE *infile = fopen(file, \"rb\");\n\tif (infile == (FILE *)NULL)\n\t{\n\t\tprintf(\"Error opening input file %s\\n\", file);\n\t\treturn 0;\n\t}\n\tresult = __hexdump_file(infile, start, start + (int)length, width);\n\t}\n\treturn result;\n}\n\nstruct BOM {\n\tint is_BOM;\n\tint length;\n\tint type;\n\tchar * type_as_string;\n\tchar * BOM;\n}\n\nint matches(char * BOM_, char * string_, int length_) {\n\tchar * b = BOM_+1;\n\tfor(int i = 0; i < length_; i++) {\n\t\tif (string_[i] == b[i]) matches = 1;\n\t\telse {\n\t\t\tmatches = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn matches;\n}\n\n#define ifbom(bom_struct, is_BOM_, length_, type_, type_as_string_, BOM_, string_) if (matches(BOM_, string_, length_)) { \\\n\tbom_struct.is_BOM = is_BOM_; \\\n\tbom_struct.length = length_; \\\n\tbom_struct.type = type_; \\\n\tbom_struct.type_as_string = type_as_string_; \\\n\tbom_struct.BOM = BOM_+1 /* remove the ^ at the start */ ; \\\n}\n\n#define elifbom(bom_struct, is_BOM_, length_, type_, type_as_string_, BOM_, string_) else ifbom(bom_struct, is_BOM_, length_, type_, type_as_string_, BOM_, string_)\n\n#define elbom(bom_struct, is_BOM_, length_, type_, type_as_string_, BOM_) else { \\\n\tbom_struct.is_BOM = is_BOM_; \\\n\tbom_struct.length = length_; \\\n\tbom_struct.type = type_; \\\n\tbom_struct.type_as_string = type_as_string_; \\\n\tbom_struct.BOM = BOM_; \\\n}\n\n#define builtin__BOM_print(bom_struct) { \\\n\tprintf(\"%s.is_BOM = %s\\n%s.length = %d\\n%s.type = %d\\n%s.type_as_string = %s\\n%s.BOM = \", #bom_struct, bom_struct.is_BOM?\"yes\":\"no\", #bom_struct, bom_struct.length, #bom_struct, bom_struct.type, #bom_struct,bom_struct.type_as_string, #bom_struct); \\\n\tmode = both; \\\n\t__hexdump_string(bom_struct.BOM, 0,bom_struct.length, 5); \\\n}\n\n\nstruct BOM builtin__BOM_get(char * string) {\n\tstruct BOM bom;\n\tifbom(bom, true, 3, 1, \"UTF-8\", \"^\\xef\\xbb\\xbf\", string)\n\telifbom(bom, true, 2, 2, \"UTF-16 (BE)\", \"^\\xfe\\xff\", string)\n\telifbom(bom, true, 2, 3, \"UTF-16 (LE)\", \"^\\xff\\xfe\", string)\n\telifbom(bom, true, 4, 4, \"UTF-32 (BE)\", \"^\\x00\\x00\\xfe\\xff\", string)\n\telifbom(bom, true, 4, 5, \"UTF-32 (LE)\", \"^\\xff\\xfe\\x00\\x00\", string)\n\telifbom(bom, true, 5, 6, \"UTF-7\", \"^\\x2b\\x2f\\x76\\x38\\x3d\", string)\n\telifbom(bom, true, 4, 7, \"UTF-7\", \"^\\x2b\\x2f\\x76\\x38\", string)\n\telifbom(bom, true, 4, 8, \"UTF-7\", \"^\\x2b\\x2f\\x76\\x39\", string)\n\telifbom(bom, true, 4, 9, \"UTF-7\", \"^\\x2b\\x2f\\x76\\x2b\", string)\n\telifbom(bom, true, 4, 10, \"UTF-7\", \"^\\x2b\\x2f\\x76\\x2f\", string)\n\telifbom(bom, true, 3, 11, \"UTF-1\", \"^\\xf7\\x64\\x4c\", string)\n\telifbom(bom, true, 4, 12, \"UTF-EBCDIC\", \"^\\xdd\\x73\\x66\\x73\", string)\n\telifbom(bom, true, 3, 13, \"SCSU\", \"^\\x0e\\xfe\\xff\", string)\n\telifbom(bom, true, 3, 14, \"BOCU-1\", \"^\\xfb\\xee\\x28\", string)\n\telifbom(bom, true, 4, 15, \"GB-18030\", \"^\\x84\\x31\\x95\\x33\", string)\n\telbom(bom, false, 0, 0, \"Not present\", \"Not present\")\n\t\n\treturn (struct BOM) bom;\n}\n\nchar * __cathexj(const char **args)\n{\n\tunsigned char * buffer;\n\tunsigned long * len;\n\tconst char * file;\n\tif (args[1] == NULL || strcmp(args[1], \"\") ==  0) {\n\t\tchar ** a;\n\t\tint c = split(\"Built-Ins/Built-Ins\", \' \', &a);\n\t\tfile = builtin__whereis(a, \".h\", false);\n\t\tfreesplit(c, &a);\n\t}\n\telse file = args[1];\n\tread__(file, (char *)&buffer, (size_t *)&len);\n\tstruct BOM d = builtin__BOM_get(buffer);\n\tbuffer += d.length;\n\tlen -= d.length;\n/*\n\nThe following characters are reserved in JSON and must be properly escaped to be used in strings:\n\nBackspace is replaced with \\b\nForm feed is replaced with \\f\nNewline is replaced with \\n\nCarriage return is replaced with \\r\nTab is replaced with \\t\nDouble quote is replaced with \\\"\nBackslash is replaced with \\\\\n\t\n*/\n\t\n\t// small sacrifice, should be done in memory\n\n\tunsigned long i;\n\tremove(\"./json\");\n\tFILE * printf_stdoutjjjjjjj = fopen(\"./json\", \"a+\");\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tif ( buffer[i] == \'\\\\\' && buffer[i+1] == \'\\n\' && i+2 == len ) fprintf(printf_stdoutjjjjjjj, \"\\\\\\n\");\n\t\telse if ( buffer[i] == \'\\\\\' && buffer[i+1] == \'\\n\' ) fprintf(printf_stdoutjjjjjjj, \"\\\\\\\\\\\\n\");\n\t\telse if ( buffer[i-1] == \'\\\\\' && buffer[i] == \'\\n\' ) {}\n\t\telse if ( buffer[i] == \'\\n\' && i+1 == len ) fprintf(printf_stdoutjjjjjjj, \"\\\\n\");\n\t\telse if ( buffer[i] == \'\\n\' ) fprintf(printf_stdoutjjjjjjj, \"\\\\n\");\n\t\telse if ( buffer[i] == \'\\t\' ) fprintf(printf_stdoutjjjjjjj, \"\\\\t\");\n\t\telse if ( buffer[i] == \'\\r\' ) fprintf(printf_stdoutjjjjjjj, \"\\\\r\");\n\t\telse if ( buffer[i] == \'\\f\' ) fprintf(printf_stdoutjjjjjjj, \"\\\\f\");\n\t\telse if ( buffer[i] == \'\\b\' ) fprintf(printf_stdoutjjjjjjj, \"\\\\b\");\n\t\telse if ( buffer[i] == \'\"\' ) fprintf(printf_stdoutjjjjjjj, \"\\\\\\\"\");\n\t\telse if ( buffer[i] == \'\\\'\' ) fprintf(printf_stdoutjjjjjjj, \"\\\\\'\");\n\t\telse if ( buffer[i] == \'\\\\\' ) fprintf(printf_stdoutjjjjjjj, \"\\\\\\\\\");\n\t\telse if ( buffer[i] < 32 || buffer[i] >= 127 ) {}\n\t\t\t//fprintf(printf_stdoutjjjjjjj, \"\\\n/* UNPRINTABLE CHARACTER %d */\\\n\", buffer[i]);\n\t\telse\n\t\t\tfprintf(printf_stdoutjjjjjjj, \"%c\", buffer[i]);\n\t}\n\tfclose(printf_stdoutjjjjjjj);\n\tchar * buf;\n\tsize_t * size;\n\tread__(\"./json\", &buf, &size);\n\td = builtin__BOM_get(buf);\n\tbuf += d.length;\n\tsize -= d.length;\n\tbuf[size] = NULL;\n\t\n\treturn strdup(buf);\n}\n\n\nint builtin__hex(const char **args) {\n\tmode = hex;\n\treturn __cathex(args);\n}\n\nint builtin__cat(const char **args) {\n\tmode = cat;\n\treturn __cathex(args);\n}\n\nint builtin__xxd(const char **args) {\n\tmode = both;\n\treturn __cathex(args);\n}\n\nchar * builtin__json(const char **args) {\n\tmode = json;\n\treturn __cathexj(args);\n}\n\nchar * filetostring(char * file) {\n\tchar * buf;\n\tsize_t size;\n\tread__(file, &buf, &size);\n\tbuf[size] = NULL;\n\treturn strdup(buf);\n}\n\nchar * chartostring(char c) {\n\tchar cc[2];\n\tcc[0] = c;\n\tcc[1] = \'\\0\';\n\treturn strdup(cc);\n}\n\nvoid builtin__coliru(char * mode, char * file, char * cmd, char * out)\n{\n\tif(access(file, F_OK) == -1) {\n\t\tprintf(file);\n\t\tputs(\" must be accessable\");\n\t\treturn;\n\t}\n\tif ((strcmp(mode, \"compile\") != 0 && strcmp(mode, \"share\") == 0) || (strcmp(mode, \"compile\") == 0 && strcmp(mode, \"share\") != 0));\n\telse {\n\t\tputs(\"must specify either \\\"compile\\\" or \\\"share\\\"\");\n\t\treturn;\n\t}\n\tif (file == NULL) {\n\t\tputs(\"must specify a file\");\n\t\treturn;\n\t}\n\tif (cmd == NULL) {\n\t\tputs(\"must specify a command (\\\" \\\" is allowed)\");\n\t\treturn;\n\t}\n\tchar ** args = env__add(env__add(env__new(), \"default\"), file);\n\tchar * s4 = builtin__json(args);\n\tfree(args);\n\tchar * s1 = \"curl \'http://coliru.stacked-crooked.com/\";\n\tchar * s2 = \"\' --data-binary \'{\\\"cmd\\\":\\\"\";\n\tchar * s3 = \"\\\n\\\",\\\"src\\\":\\\"\";\n\tchar * s5;\n\tif (out == NULL) {\n\t\ts5 = \"\\\"}\'\";\n\t\tout = \"\";\n\t}\n\telse {\n\t\ts5 = \"\\\"}\' -o \";\n\t}\n\tchar * line = malloc(\n\tstrlen(s1)+\n\tstrlen(mode)+\n\tstrlen(s2)+\n\tstrlen(cmd)+\n\tstrlen(s3)+\n\tstrlen(s4)+\n\tstrlen(s5)+\n\tstrlen(out)\n\t);\n\tsprintf(line, \"%s%s%s%s%s%s%s%s\", s1, mode, s2, cmd, s3, s4, s5, out);\n\t//puts(line);\n\tif (strcmp(mode, \"share\") == 0) printf(\"http://coliru.stacked-crooked.com/a/\");\n\tsystem(line);\n\tputs(\"\");\n}\n\nchar * __find_unknown(int type) {\n\tchar unknown[10+16];\n\tsprintf(unknown, \"unknown (%d)\", type);\n\treturn unknown;\n}\n\nchar * __find_gettype (int type) {\n\tif (type==8) return \"file\";\n\telse if (type==4) return \"folder\";\n\telse return __find_unknown(type);\n}\n\nint builtin__ls(const char ** args) {\n\tDIR *pDir;\n\tstruct dirent *ent;\n\tchar * path = args[1]==NULL?\"./\":args[1];\n\tpDir = opendir(path);\n\tif (pDir)\n\t{\n\t\twhile ((ent = readdir(pDir)) != NULL) printf(\"%s : %s\\n\", ent->d_name, __find_gettype(ent->d_type));\n\t\tclosedir(pDir);\n\t}\n\telse {\n\t\tprintf(\"Access to %s was denied\\n\", path);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n#define file__path 1\n#define file__relative 2\n#define file__directory 3\n\nchar * builtin__whereis(char ** f, const char * extention, int skip_arg0) {\n\tint mode, arg_number;\n\tif(*f[skip_arg0] == \'.\' && *f[skip_arg0]+1 == \'/\') mode = file__relative;\n\telse if (*f[skip_arg0] == \'/\') mode = file__directory;\n\telse {\n\t\tchar ** tt;\n\t\tint c = split(f[skip_arg0], \'/\', &tt);\n    \tif (c == 1 && *f[skip_arg0] != \'.\') mode = file__path;\n    \tfreesplit(c, &tt);\n    \tputs(\"is file path\");\n\t}\n\t\n\tchar * file = f[skip_arg0];\n\t\n\tif (mode == file__relative || mode == file__directory) return strdup(f[skip_arg0]);\n\telse {\n\t\tchar * path = env__get(environ_default?environ_default:environ, \"PATH\");\n\t\tchar ph[4096];\n\t  \tif (!path) path = \"/bin:/usr/bin:/usr/local/bin\";\n\t\tsprintf(path, \"%s:%s/CCR/Scripts\", path, env__get(environ_default?environ_default:environ, \"CPP_RESOURCE_DIR\"));\n\t\tif (path == NULL) {\n\t\t\tputs(\"environment variable PATH is unset; cannot proceed\");\n\t\t\treturn NULL;\n\t\t}\n\t\tchar *hardcoded_platform_specific_path_separator = \":\";\n\t\tchar * pathtmp = strdup(path);\n\t\tfor (char *tok = strtok(pathtmp, hardcoded_platform_specific_path_separator); tok; tok = strtok(NULL, hardcoded_platform_specific_path_separator)) {\n\t\t\tsprintf(ph, \"%s/%s%s\", tok, file, extention);\n\t\t\tprintf(\"tryingA %s....   \\n\", ph);\n\t\t\tif (access(ph, F_OK) == 0) {\n\t      \t\tprintf(\"foundA at %s\\n\", ph);\n\t      \t\treturn ph;\n\t      \t}\n\t\t}\n\t\tfree(pathtmp);\n\t\tpathtmp = strdup(path);\n\t\tfor (char *tok = strtok(pathtmp, hardcoded_platform_specific_path_separator); tok; tok = strtok(NULL, hardcoded_platform_specific_path_separator)) {\n\t\t\tsprintf(ph, \"%s/%s.proj%s\", tok, file, extention);\n\t\t\tprintf(\"tryingB %s....   \\n\", ph);\n\t\t\tif (access(ph, F_OK) == 0) {\n\t      \t\tprintf(\"foundB at %s\\n\", ph);\n\t      \t\treturn ph;\n\t      \t}\n\t\t}\n\t\tfree(pathtmp);\n\t\tsprintf(ph, \"./%s%s\", file, extention);\n\t\tprintf(\"tryingA %s....   \\n\", ph);\n\t\tif (access(ph, F_OK) == 0) {\n\t      \tprintf(\"foundA at %s\\n\", ph);\n\t      \t\treturn ph;\n\t    }\n\t\tsprintf(ph, \"./%s.proj%s\", file, extention);\n\t\tprintf(\"tryingA %s....   \\n\", ph);\n\t      if (access(ph, F_OK) == 0) {\n\t      \tprintf(\"foundA at %s\\n\", ph);\n\t      \t\treturn ph;\n\t      }\n\t}\n\tprintf(\"%s: %s not found\\n\", skip_arg0?file:shell.name, file);\n\treturn NULL;\n}\n\n\n\n// we enum to allow for preprocessing of #x as definition string of the define itself instead of its value\nenum {\n\t// prepend _ to allow for preprocessing to still work (if any is done) on these defines\n\t_CPP_NO_ERROR=CPP_NO_ERROR,\n\t_CPP_OUT_OF_MEMORY=CPP_OUT_OF_MEMORY,\n\t_CPP_INVALID_ARGUMENTS=CPP_INVALID_ARGUMENTS,\n\t_CPP_INTERNAL_ERROR=CPP_INTERNAL_ERROR,\n\t_CPP_PARSING_ERROR=CPP_PARSING_ERROR,\n\t_CPP_LINKING_ERROR=CPP_LINKING_ERROR,\n\t_CPP_RUNNING_ERROR=CPP_RUNNING_ERROR\n}\n\n#define __return(function) printf(\"%s returned %d\\n\", #function, function);\n\n#define retv(ret, x) if(ret == x) return #x+1; // trim the leading _\n\n#define retc(x) retv(x, _CPP_INTERNAL_ERROR) retv(x, _CPP_INVALID_ARGUMENTS) retv(x, _CPP_LINKING_ERROR) retv(x, _CPP_NO_ERROR) retv(x, _CPP_OUT_OF_MEMORY) retv(x, _CPP_PARSING_ERROR) retv(x, _CPP_RUNNING_ERROR)\n\nconst char * return_cpp_error_code(int ret) {\n\tretc(ret)\n\treturn \"(null)\";\n}\n\nCPPenum cpp_y;\nconst char * cpp_z;\n\n#define cpp_check1(x) printf(\"%s returned %s\\n\", #x, return_cpp_error_code(x));\n\n// same code above but with proper error checking\n#define cpp_check(x) { \\\n\tcpp_y = x; \\\n\tcpp_z = return_cpp_error_code(cpp_y); \\\n\tif (strcmp(cpp_z, cpp_y==_CPP_NO_ERROR?\"CPP_NO_ERROR\":\"NULL\") != 0) { \\\n\t\tprintf(\"%s returned %s\\n\", #x, cpp_z); \\\n\t\treturn -1; \\\n\t} \\\n}\n\nconst char *userHeaderSearchPaths[] = {};\nconst char *defines[] = { \"#define DEVNULLSOMETHINGFOOBAR\" };\n\nvoid attachSourceFile(CPPuint programID, const char *fileName);\nconst char *getFileExtension(const char *fileName);\n\nCPPuint programID = 0;\n\n#define attachSourceFile(x, y) { \\\n\tCPPuint objectID = cppCreateObject(); \\\n\\\n\t/* Set user header search paths. */ \\\n\tfor (int i = 0; i < sizeof(userHeaderSearchPaths) / sizeof(userHeaderSearchPaths[0]); i++) \\\n\t\tcpp_check(cppObjectAddUserHeaderSearchPath(objectID, userHeaderSearchPaths[i])); \\\n\\\n\t/* Macro definitions... */ \\\n\tfor (int i = 0; i < sizeof(defines) / sizeof(defines[0]); i++) \\\n\t\tcpp_check(cppObjectAddPrologue(objectID, defines[i])); \\\n\\\n\tcpp_check(cppObjectSourceFile(objectID, y)); \\\n\tcpp_check(cppCompileObject(objectID)); \\\n\tcpp_check(cppAttachObject(x, objectID)); \\\n\tcpp_check(cppDeleteObject(objectID)); \\\n}\n\t\n\t\n\t\n\t\n\t\n\nint builtin__gcc(const char **args) {\n\tconst char * file = builtin__whereis(args, \".c\", true);\n\tif (strcmp(file,\"NULL\") == 0) {\n\t\tprintf(\"%s: error: input is NULL\\n\", args[0]);\n\t\treturn -1;\n\t}\n\tprogramID = cppCreateProgram();\n\t//attachSourceFile(programID, \"wrappers.h\"); // add our wrapper file first\n\tattachSourceFile(programID, file);\n\tDEBUG printf(\"Compiling and linking...\\n\");\n\tcpp_check(cppLinkProgram(programID));\n\tDEBUG printf(\"Running...\\n\");\n\tcpp_check(cppRunProgram(programID));\n\tDEBUG printf(\"Finished running.\\n\");\n\tif (programID) cppDeleteProgram(programID);\n\treturn 0;\n}\n