#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stddef.h>\n#include <ctype.h>\n\n#ifdef __CCR__\n#include \"../Built-Ins/Built-Ins.h\"\n#endif\n#ifndef __CCR__\n// supply the functions if used\nchar * chartostring(char c) {\n\tchar cc[2];\n\tcc[0] = c;\n\tcc[1] = \'\\0\';\n\treturn strdup(cc);\n}\n#endif\n\nint debug_tok = 0;\nint debug_char = 0;\nint debug_scope = 0;\n\nstruct ret {\n\tint type;\n\tint start_pos;\n\tint end_pos;\n\tint length;\n};\n\n#define type_parenthesis  \t\t// ()\n#define type_curly_brackets \t// {}\n#define type_brackets \t\t\t// []\n#define type_single_quote \t\t// \'\'\n#define type_double_quote \t\t// \"\"\n#define type_hash \t\t\t\t// #\n#define dollar_char   \'$\'\n#define dollar_string \"$\"\n\n/*\n\nrules: attempt to follow the bash parse.y closely, modifying as desired\n\nall returns shall have a type, length, start position, and end position\n\nif dollar occurs we return it and its scope if applicable\n\nif function scope we return the function name and its scope\n\nif normal scope we return it\n\n*/\n\nstruct scope\n{\n\tint is_parenthesis; \t// ()\n\tint is_curly_brackets;\t// {}\n\tint is_brackets;\t\t// []\n\tint is_single_quote;\t// \'\'\n\tint is_double_quote;\t// \"\"\n\tint is_hash;\t\t\t// #\n\tint is_scope_start;\n\tint is_not_scope;\n\tint current_scope;\n\tint last_scope[256];\n\tint scope_depth;\n\tint scope_state;\n\tint toggle;\n\tint got;\n} a;\n\nchar * token;\nint token_column;\nchar * last_token;\nint last_token_column;\nchar * last_token_before_that;\nint last_token_before_that_column;\nchar * word;\nint word_column;\nchar * last_word;\nint last_word_column;\nchar * last_word_before_that;\nint last_word_before_that_column;\nchar ii;\nint pp;\n\n\nint line_global = 1;\nint column_global = 0;\n\n// macro definitions\n#define tok if ((a.current_scope == -1 || a.scope_depth == 0) && token == NULL) { \\\n\t\t\t\ttoken = chartostring(i[p]); \\\n\t\t\t\ttoken_column = column_local; \\\n\t\t\t} \\\n\t\t\telse if((a.current_scope == -1 || a.scope_depth == 0) && token != NULL) { \\\n\t\t\t\tlast_token_before_that = strdup(last_token); \\\n\t\t\t\tlast_token_before_that_column = column_local<2>=0?column_local-2:0; \\\n\t\t\t\tlast_token = strdup(token); \\\n\t\t\t\tlast_token_column = column_local-1>=0?column_local-1:0; \\\n\t\t\t\ttoken = chartostring(i[p]); \\\n\t\t\t\ttoken_column = column_local; \\\n\t\t\t}\n\t\t\t\n#define tokp if (debug_tok) { if(token != NULL) printf(\"token = \\\"%s\\\", token_column = %d, \", token, token_column); \\\n\t\t\t\tif(last_token != NULL) printf(\"last_token = \\\"%s\\\", last_token_column = %d, \", last_token, last_token_column); \\\n\t\t\t\tif(last_token_before_that != NULL) printf(\"last_token_before_that = \\\"%s\\\", last_token_before_that_column= %d, \", last_token_before_that, last_token_before_that_column); \\\n\t\t\t\tif(word != NULL) printf(\"word = \\\"%s\\\", word_column = %d, \", word, word_column); \\\n\t\t\t\tif(last_word != NULL) printf(\"last_word = \\\"%s\\\", last_word_column = %d, \", last_word, last_word_column); \\\n\t\t\t\tif(last_word_before_that != NULL) printf(\"last_word_before_that = \\\"%s\\\", last_word_before_that_column = %d, \", last_word_before_that, last_word_before_that_column); }\n\t\t\t\n#define scope_enter(x) a.scope_state = 1; \\\n\t\t\t\ta.scope_depth++; \\\n\t\t\t\ta.last_scope[a.scope_depth] = a.current_scope; \\\n\t\t\t\ta.current_scope=x;\n\t\t\t\t\n#define scope_exit a.scope_state = 2; \\\n\t\t\t\ta.scope_depth--; \\\n\t\t\t\ta.last_scope[a.scope_depth] = a.last_scope[a.scope_depth+1];\n\t\t\t\n#define scope_toggle_enter(x) a.toggle = 1; \\\n\t\t\t\ta.scope_state = 8;\\\n\t\t\t\ta.scope_depth++; \\\n\t\t\t\ta.last_scope[a.scope_depth] = a.current_scope; \\\n\t\t\t\ta.current_scope=x;\n\t\t\t\n#define scope_toggle_exit a.toggle = -1; \\\n\t\t\t\ta.scope_state = 2; \\\n\t\t\t\ta.scope_depth--; \\\n\t\t\t\ta.last_scope[a.scope_depth] = a.last_scope[a.scope_depth+1]; \n\t\t\t\nint which_token_int(char * desired) {\n\tif (strcmp(token, desired) == 0) return 0;\n\telse if (strcmp(last_token, desired) == 0) return 0;\n\telse if (strcmp(last_token_before_that, desired) == 0) return 0;\n\telse return -1;\n}\n\nint which_token_order_int(char * desired1, char * desired2) {\n\t// token order is reversed\n\tif (strcmp(token, desired2) == 0) {\n\t\tif (strcmp(last_token, desired1) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn -1;\n\t}\n\telse if (strcmp(last_token, desired2) == 0) {\n\t\tif (strcmp(last_token_before_that, desired1) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn -1;\n\t}\n\telse return -1;\n}\n\nchar * which_token_char(char * desired) {\n\tif (which_token_int(desired) == -1) return \"(null)\";\n\telse if (strcmp(token, desired) == 0) return token;\n\telse if (strcmp(last_token, desired) == 0) return last_token;\n\telse if (strcmp(last_token_before_that, desired) == 0) return last_token_before_that; \n}\n\n#define reset(x) memset(x, 0, strlen(x))\n\t\t\t\nvoid parse(char * i, char * delim) {\n\tint input_len = strlen(i);\n\tint line_local = 1;\n\tint column_local = 0;\n\tif (strcmp(delim, \"(\") == 0 || strcmp(delim, \")\") == 0 || strcmp(delim, \"{\") == 0 || strcmp(delim, \"}\") == 0 || strcmp(delim, \"[\") == 0 || strcmp(delim, \"]\") == 0 || strcmp(delim, \"\'\") == 0 || strcmp(delim, \"\\\"\") == 0 || strcmp(delim, \"#\") == 0 || strcmp(delim, dollar_string) == 0 || strcmp(delim, \"=\") == 0) {\n\t\tputs(\"delimiter cannot be a reserved scope delimiter\");\n\t\treturn;\n\t};\n\ta.toggle = -1;\n\ta.is_parenthesis == -1;\n\ta.is_curly_brackets == -1;\n\ta.is_brackets == -1;\n\ta.is_single_quote == -1;\n\ta.is_double_quote == -1;\n\ta.is_hash == -1;\n\ta.current_scope\t= -1;\n\ta.got = -1;\n\tint sh = -1;\n\tint hash = -1;\n\tint p = 0;\n\tii = i[p];\n\tpp = p;\n\tchar * buffer = malloc( input_len );\n\tchar * bufferb = malloc( input_len );\n\tchar * input = strdup(i);\n\t\n\ttoken = malloc(10);\n\tlast_token = malloc(10);\n\tlast_token_before_that = malloc(10);\n\tword = malloc( input_len );\n\tlast_word = malloc( input_len );\n\tlast_word_before_that = malloc( input_len );\n\t\n\ttoken_column = 0;\n\tlast_token_column = 0;\n\tlast_token_before_that_column = 0;\n\tword_column = 0;\n\tlast_word_column = 0;\n\tlast_word_before_that_column = 0;\n\t\n\tprintf(\"original: \\\"%s\\\"\\n\", i);\n\t\t\t\n\twhile(i[p]) {\n\t\tcolumn_global++;\n\t\tcolumn_local++;\n\t\tii = i[p];\n\t\tpp = p;\n\t\tstrcat(bufferb, chartostring(i[p]));\n\t\tif (debug_char) printf(\"i[%0*d] = %c, buffer = %s\\n\", snprintf(stdout, 0, \"%d\", input_len), p, i[p], buffer);\n\t\t\n\t\tif (a.toggle == -1 && a.is_parenthesis == -1 && a.is_curly_brackets == -1 && a.is_brackets == -1 && a.is_single_quote == -1 && a.is_double_quote == -1 && a.is_hash == -1 && sh == -1) {}\n\t\telse a.got = 1;\n\t\t\n\t\tif (a.is_parenthesis == -1 && a.is_curly_brackets == -1 && a.is_brackets == -1 && a.is_single_quote == -1 && a.is_double_quote == -1 && a.is_hash == -1) a.current_scope = -1;\n\t\telse a.is_not_scope = 1;\n\t\t\n\t\tif(a.current_scope == -1 && i[p-1] == \'\\n\')\n\t\t{\n\t\t\tline_global++;\n\t\t\tcolumn_global = 0;\n\t\t\tline_local++;\n\t\t\tcolumn_local = 0;\n\t\t\treset(token);\n\t\t\treset(last_token);\n\t\t\treset(last_token_before_that);\n\t\t\treset(word);\n\t\t\treset(last_word);\n\t\t\treset(last_word_before_that);\n\t\t\ttoken_column = 0;\n\t\t\tlast_token_column = 0;\n\t\t\tlast_token_before_that_column = 0;\n\t\t\tword_column = 0;\n\t\t\tlast_word_column = 0;\n\t\t\tlast_word_before_that_column = 0;\n\t\t}\n\t\t\n\t\tif (sh == 1) {}\n\t\telse if (a.current_scope == -1 && isspace(i[p-1])) {\n\t\t\tif (i[p] == \'(\') {}\n\t\t\telse if (i[p] == \')\') {}\n\t\t\telse if (i[p] == \'{\') {}\n\t\t\telse if (i[p] == \'}\') {}\n\t\t\telse if (i[p] == \'=\') {}\n\t\t\telse if (i[p] == \'<\') {}\n\t\t\telse if (i[p] == \'[\') {}\n\t\t\telse if (i[p] == \']\') {}\n\t\t\telse if (i[p] == \'\"\') {}\n\t\t\telse if (i[p] == \'\\\'\') {}\n\t\t\telse if (i[p] == \'#\') {}\n\t\t\telse if (i[p] == \'!\') {}\n\t\t\telse if (i[p] == \'&\') {}\n\t\t\telse if (i[p] == dollar_char) {}\n\t\t\telse if (i[p] == \'-\' || isalnum(i[p])) {\n\t\t\t\tlast_word_before_that = strdup(last_word);\n\t\t\t\tmemcpy(&last_word_before_that_column, &last_word_column, sizeof(last_word_before_that_column));\n\t\t\t\tlast_word_before_that_column = last_word_column;\n\t\t\t\tlast_word = strdup(word);\n\t\t\t\tmemcpy(&last_word_column, &word_column, sizeof(last_word_column));\n\t\t\t\tmemset(word, 0, strlen(word));\n\t\t\t\tstrcat(word, chartostring(i[p]));\n\t\t\t\tmemcpy(&word_column, &column_local, sizeof(word_column));\n\t\t\t}\n\t\t}\n\t\telse if(a.current_scope == -1 && isalnum(i[p])) {\n\t\t\tstrcat(word, chartostring(i[p]));\n\t\t}\n\t\t\n\t\tif (i[p] == \'(\') {\n\t\t\ttok;\n\t\t\tscope_enter(1);\n\t\t\ta.is_parenthesis++;\n\t\t}\n\t\telse if (i[p] == \')\') {\n\t\t\tscope_exit\n\t\t\ttok\n\t\t\ta.is_parenthesis--;\n\t\t}\n\t\telse if (i[p] == \'{\') {\n\t\t\ttok\n\t\t\tscope_enter(2);\n\t\t\ta.is_curly_brackets++;\n\t\t}\n\t\telse if (i[p] == \'}\') {\n\t\t\ttok\n\t\t\tscope_exit\n\t\t\ta.is_curly_brackets--;\n\t\t}\n\t\telse if (i[p] == \'[\') {\n\t\t\ttok\n\t\t\tscope_enter(3);\n\t\t\ta.is_brackets++;\n\t\t}\n\t\telse if (i[p] == \']\') {\n\t\t\ttok\n\t\t\tscope_exit\n\t\t\ta.is_brackets--;\n\t\t}\n\t\telse if (i[p] == \'=\') {\n\t\t\ttok\n\t\t}\n\t\telse if (i[p] == \'<\') {\n\t\t\ttok\n\t\t}\n\t\telse if (i[p] == \'!\') {\n\t\t\ttok\n\t\t}\n\t\telse if (i[p] == \'\"\') {\n\t\t\tif (a.toggle == -1) {\n\t\t\t\ttok\n\t\t\t\tscope_toggle_enter(5);\n\t\t\t\ta.is_double_quote++;\n\t\t\t}\n\t\t\telse if (a.toggle == 1) {\n\t\t\t\ttok\n\t\t\t\tscope_toggle_exit\n\t\t\t\ta.is_double_quote--;\n\t\t\t}\n\t\t}\n\t\telse if (i[p] == \'\\\'\') {\n\t\t\tif (a.toggle == -1) {\n\t\t\t\ttok\n\t\t\t\tscope_toggle_enter(6);\n\t\t\t\ta.is_single_quote++;\n\t\t\t}\n\t\t\telse if (a.toggle == 1) {\n\t\t\t\ttok\n\t\t\t\tscope_toggle_exit\n\t\t\t\ta.is_single_quote--;\n\t\t\t}\n\t\t}\n\t\telse if (i[p] == \'&\') {\n\t\t\ttok\n\t\t}\n\t\telse if (i[p] == \'|\') {\n\t\t\ttok\n\t\t}\n\t\telse if(i[p] == dollar_char && a.current_scope == -1) {\n\t\t\ttok\n\t\t\t//printf(\"dollar detected, \");\n\t\t\tsh = 1;\n\t\t}\n\t\telse if(i[p] == \'#\' && a.current_scope == -1) {\n\t\t\ttok\n\t\t\t//printf(\"dollar detected, \");\n\t\t\thash = 1;\n\t\t\ta.is_hash++;\n\t\t}\n\t\tif ((sh == 1 || hash == 1) && a.current_scope == -1 && i[p] != \'\\0\' && i[p] != \' \' && i[p] != \'\\n\') strcat(buffer, chartostring(i[p]));\n\t\telse if (sh == 1 && a.current_scope == -1 && (i[p] == \'\\0\' || i[p] == \' \' || i[p] == \'\\n\')) {\n\t\t\tsh = -1;\n\t\t\tif (buffer != NULL && strcmp(buffer, \"\") != 0) {\n\t\t\t\tprintf(\"line: %d, \", line_global);\n\t\t\t\ttokp\n\t\t\t\tif (which_token_int(\"=\") == 0 && word != NULL) printf(\"assignment: %s%s%s\\n\", word, which_token_char(\"=\"), buffer);\n\t\t\t\telse printf(\"shell variable reference: %s\\n\", buffer);\n\t\t\t}\n\t\t\tmemset(buffer, 0, strlen(buffer));\n\t\t}\n\t\telse if (hash == 1 && a.current_scope == -1 && (i[p] == \'\\0\' || i[p] == \' \' || i[p] == \'\\n\')) {\n\t\t\thash = -1;\n\t\t\tif (buffer != NULL && strcmp(buffer, \"\") != 0 && which_token_order_int(\"#\", \"!\") == 0) {\n\t\t\t\tprintf(\"line: %d, \", line_global);\n\t\t\t\ttokp\n\t\t\t\tprintf(\"shebang: %s\\n\", buffer);\n\t\t\t}\n\t\t\tmemset(buffer, 0, strlen(buffer));\n\t\t}\n\t\tif (a.current_scope != -1) {\n\t\t\tstrcat(buffer, chartostring(i[p]));\n\t\t\tif (debug_scope) printf(\"(scope state: %d, scope depth:%d, current scope: %d, last scope: %d) i[%d] = %c\\n\", a.scope_state, a.scope_depth, a.current_scope, a.last_scope[a.scope_depth], p, i[p]);\n\t\t}\n\t\tif (a.scope_state == 1) a.scope_state = 3;\n\t\telse if (a.scope_state == 2) {\n\t\t\ta.scope_state = 4;\n\t\t\tif (a.scope_depth == 0) {\n\t\t\t\ta.current_scope = -1;\n\t\t\t\tif (buffer != NULL) {\n\t\t\t\t\tprintf(\"line: %d, \", line_global);\n\t\t\t\t\ttokp\n\t\t\t\t\tif (sh = 1 && which_token_int(\"=\") == 0 && word != NULL) printf(\"assignment: %s%s%s\\n\", word, which_token_char(\"=\"), buffer);\n\t\t\t\t\t// if dollar is detected we do not scope, however not scoping then brings up more problems so instead we detect it from the scope itself\n\t\t\t\t\telse if (which_token_order_int(dollar_string, \"(\") == 0) printf(\"shell variable command substitution reference: %s\\n\", buffer);\n\t\t\t\t\telse if (which_token_order_int(\"<\", \"(\") == 0) printf(\"process substitution: <%s\\n\", buffer);\n\t\t\t\t\telse if (which_token_order_int(dollar_string, \"{\") == 0) printf(\"shell variable array reference: %s\\n\", buffer);\n\t\t\t\t\telse if (which_token_order_int(\"(\", \")\") == 0 && word != NULL) printf(\"function declaration: %s%s\\n\", word, buffer);\n\t\t\t\t\telse if (which_token_order_int(\"(\", \")\") == 0) printf(\"compound command: %s\\n\", buffer);\n\t\t\t\t\telse if (which_token_int(\"[\") == 0) printf(\"test statement: %s\\n\", buffer);\n\t\t\t\t\telse if (which_token_int(\"{\") == 0) printf(\"code block: %s\\n\", buffer);\n\t\t\t\t\telse if (which_token_int(\"\\\"\") == 0) printf(\"double quotes: %s\\n\", buffer);\n\t\t\t\t\telse if (which_token_int(\"\'\") == 0) printf(\"single quotes: %s\\n\", buffer);\n\t\t\t\t\telse printf(\"unknown: %s\\n\", buffer);\n\t\t\t\t}\n    \t\t\tmemset(buffer, 0, strlen(buffer));\n\t\t\t}\n\t\t\telse a.current_scope=a.last_scope[a.scope_depth];\n\t\t}\n\t\telse if (a.current_scope == -1 && (i[p] == \'\\0\' || i[p] == \' \' || i[p] == \'\\n\')) {\n\t\t\tif (i[p] == \' \' && word && which_token_order_int(\"&\", \"&\") == 0 && strcmp(last_word,\"\") != 0) {\n\t\t\t\tprintf(\"line: %d, \", line_global);\n\t\t\t\ttokp\n\t\t\t\tprintf(\"logical AND: %s%s%s%s\\n\", last_word, token, last_token, word);\n\t\t\t\treset(token);\n\t\t\t\treset(last_token);\n\t\t\t\treset(last_word);\n\t\t\t}\n\t\t\telse if (word && which_token_order_int(\"&\", \"&\") == 0 && strcmp(last_word,\"\") != 0) {\n\t\t\t\tprintf(\"line: %d, \", line_global);\n\t\t\t\ttokp\n\t\t\t\tprintf(\"logical AND: %s%s%s%s\\n\", last_word, token, last_token, word);\n\t\t\t}\n\t\t\telse if (i[p] == \' \' && word && which_token_order_int(\"|\", \"|\") == 0 && strcmp(last_word,\"\") != 0) {\n\t\t\t\tprintf(\"line: %d, \", line_global);\n\t\t\t\ttokp\n\t\t\t\tprintf(\"logical OR : %s%s%s%s\\n\", last_word, token, last_token, word);\n\t\t\t\treset(token);\n\t\t\t\treset(last_token);\n\t\t\t\treset(last_word);\n\t\t\t}\n\t\t\telse if (word && which_token_order_int(\"|\", \"|\") == 0 && strcmp(last_word,\"\") != 0) {\n\t\t\t\tprintf(\"line: %d, \", line_global);\n\t\t\t\ttokp\n\t\t\t\tprintf(\"logical OR: %s%s%s%s\\n\", last_word, token, last_token, word);\n\t\t\t}\n\t\t}\n\t\tp++;\n\t}\n    memset(buffer, 0, strlen(buffer));\n    free(buffer);\n\tfree(token);\n\tfree(last_token);\n}\n\n\nint main() {\n\t#ifndef __CCR__\n\t// supply the file as json compatible (or quote safe) string\n\tchar * string = \"#!/bin/bash\\na && b\\ng && j || h && s\\ng&&j||h&&s\\nstrippath()\\n{\\n    realpath1=$(readlink -f $1)\\n    pathdir1=$(dirname \\\"$realpath1\\\")\\n    pathdir1=\\\"$pathdir1/\\\"\\n    echo $pathdir1\\n}\\n\\nif [[ -d $path ]]; then\\n    echo $path is a directory\\n    stripped=$(strippath $path)\\n    pathreal=$(readlink -f $path)\\n    mapfile -d \\\'\\\' -t filesreal < <(find \\\"${pathreal[0]}\\\" -type f -print0)\\n    mapfile -d \\\'\\\' -t dirsreal < <(find \\\"${pathreal[0]}\\\" -type d -print0)\\n    echo execute function: preinitmulti\\n    count=1\\n    for i in ${!filesreal[@]} ; do\\n    pathdir=$(dirname \\\"${filesreal[i]}\\\")\\n    pathdir=\\\"$pathdir/\\\"\\n    pathbase=(\\\"${filesreal[i]#$pathdir}\\\")\\n    pathstripped=(\\\"${pathdir#$stripped}\\\")\\n    echo\\n    echo \\\"execute function: objectconvertMulti with arguments (full file path:) ${filesreal[i]}, (identifier to avoid object collisions:) $i, (directory to be created on extraction:) $pathstripped, (file to be created on extraction:) ${pathbase[0]}\\\"\\n    echo\\n    echo ${filesreal[i]} processed\\n    done\\n    echo execute function: fin\\n    echo execute function: compilemulti\\n    echo execute function: finishmulti\\n    exit\\nfi\\n\\npath=$@\\n\";\n\t#endif\n\t#ifdef __CCR__\n\t// else obtain it natively via built-ins header\n\tchar * string = filetostring(\"test.sh\");\n\t#endif\n    \n\tparse(string, \" \");\n\t\n    return 0;\n}\n